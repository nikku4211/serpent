vars /serp_vars
    UF px = 12
    UF py = 10
    UF opx = 12
    UF opy = 10
    U pleat = 0
    U[256] psnpx
    U[256] psnpy
    U psnpxbi = 0
    U psnpybi = 0
    SF pvelx = 0.1
    SF pvely = 0
    SF opvelx = 0.1
    SF opvely = 0
    U plength = 5
    U pheadt = 8
    U pbodyt = 7
    U ptailt = 5
    U pcornt = 7
    U optailt_counter = 7
    U optailt = 5
    Bool pturn = false
    UF rx = 16
    UF ry = 15
    UF orx = 16
    UF ory = 15
    U rt = 11
    SF rvelx = 0.1
    SF rvely = 0
    U rtele = 0
    U ortele = 0
    U score = 0
    Bool lost = false
    U shame_counter = 120
    U shame_scroll = 0
    UU wintro_counter = 384

data /serp_data
    [] game_back_nt
        file(raw, "gamebkg.nam")
    [] title_back_nt
        file(raw, "title.nam")
    [] win_back_nt
        file(raw, "win.nam")
    [] lose1_back_nt
        file(raw, "lose1.nam")
    [] lose2_back_nt
        file(raw, "lose2.nam")
ct U [25] nexxt_default = file(raw, "nexxtdefaultnf.pal")

fn load_nametable(CCC/serp_data nametable)
    ppu_reset_addr($2000)
    for UU i = 0; i < 960; i += 1
        {PPUDATA}(nametable{i})
    for UU i = 0; i < 64; i += 1
        {PPUDATA}(nametable{i+960})

fn load_nametable_tall()
    ppu_reset_addr($2000)
    for UU i = 0; i < 960; i += 1
        {PPUDATA}(@lose1_back_nt{i})
    for UU i = 0; i < 64; i += 1
        {PPUDATA}(@lose1_back_nt{i+960})
    ppu_set_addr($2800)
    for UU i = 0; i < 960; i += 1
        {PPUDATA}(@lose2_back_nt{i})
    for UU i = 0; i < 64; i += 1
        {PPUDATA}(@lose2_back_nt{i+960})

fn init_arrays()
    //clear the entire 256-byte array...
    for U i = 0; i < 255; i += 1
        psnpx[i] = 0
    for U i = 0; i < 255; i += 1
        psnpy[i] = 0
    
    //...even the 256th byte
    psnpx[255] = 0
    psnpy[255] = 0

    psnpx[0] = px.a
    psnpy[0] = py.a
    psnpxbi = 1
    psnpybi = 1

fn init_game_vars()
    px = 12
    py = 10
    opx = 12
    opy = 10
    pleat = 0
    psnpxbi = 0
    psnpybi = 0
    pvelx = 0.1
    pvely = 0
    opvelx = 0.1
    opvely = 0
    plength = 5
    pheadt = 8
    pbodyt = 7
    ptailt = 5
    pcornt = 7
    optailt_counter = 7
    optailt = 5
    pturn = false
    rx = 16
    ry = 15
    orx = 16
    ory = 15
    rt = 11
    rvelx = 0.1
    rvely = 0
    rtele = 0
    ortele = 0
    score = 0

nmi main_nmi()
    //update oam and poll controller presses
    ppu_upload_oam_poll_pads(0)

    //turn rendering on
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    update_bkg()

    //reset scroll
    ppu_reset_scroll(0, 0)

    puf.process(PUF_DEFAULT)

mode game()
: nmi main_nmi
    
    // turn NMI off
    {PPUCTRL}(0)
    //turn rendering off
    {PPUMASK}(0)

    puf.play_track(puf_track_game)

    // load the level
    load_nametable(@game_back_nt)

    init_game_vars()

    init_arrays()

    set_rat()

    // have NMI on every frame
    {PPUCTRL}(PPUCTRL_NMI_ON)

    puf.play_sfx(0)

    while true
        update_pads()
        move_player()
        move_rat()
        eat_check()
        
        if score == 20
            goto mode win()
            : preserves
        if lost
            goto mode lose()
            : preserves
        nmi

nmi win_nmi()
    //update oam and poll controller presses
    ppu_upload_oam_poll_pads(0)

    //turn rendering on
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    //reset scroll
    ppu_set_scroll(0, shame_scroll)
    
    puf.process(PUF_DEFAULT)

mode win()
: nmi win_nmi
    // turn NMI off
    {PPUCTRL}(0)
    //turn rendering off
    {PPUMASK}(0)

    load_nametable(@win_back_nt)

    puf.play_track(puf_track_wintro)

    // have NMI on every frame
    {PPUCTRL}(PPUCTRL_NMI_ON)

    while true
        update_pads()
        pads_menu()
        if wintro_counter > 0 && wintro_counter < 385
            wintro_counter -= 1
        if wintro_counter == 0
            wintro_counter = 385
            puf.play_track(puf_track_win)

        nmi

fn update_bkg()   

    //read the snake head on the background
    fence
    ppu_set_addr($2000+(UU(py.a)<<5)+UU(px.a))
    pleat = {PPUDATA}()
    pleat = {PPUDATA}()
    fence

    //read the rat on the background
    fence
    ppu_set_addr($2000+(UU(ry.a)<<5)+UU(rx.a))
    rtele = {PPUDATA}()
    rtele = {PPUDATA}()
    fence

    ouro_check()

    //draw a black space over the old rat on the background
    ppu_set_addr($2000+(UU(ory.a)<<5)+UU(orx.a))
    {PPUDATA}(ortele)

    //draw the snake body on the background
    ppu_set_addr($2000+(UU(opy.a)<<5)+UU(opx.a))
    {PPUDATA}(pbodyt)

    //draw the snake corner on the background if turn
    if pturn
        ppu_set_addr($2000+(UU(opy.a)<<5)+UU(opx.a))
        {PPUDATA}(pcornt)

    //draw the snake head on the background
    ppu_set_addr($2000+(UU(py.a)<<5)+UU(px.a))
    {PPUDATA}(pheadt)

    //draw a blank space over the snake tail on the background
    ppu_set_addr($2000+(UU(psnpy[psnpybi-plength])<<5)+UU(psnpx[psnpxbi-plength]))
    {PPUDATA}(0)

    //draw the snake tail on the background
    ppu_set_addr($2000+(UU(psnpy[psnpybi-(plength-1)])<<5)+UU(psnpx[psnpxbi-(plength-1)]))
    {PPUDATA}(optailt)

    //draw the rat on the background
    ppu_set_addr($2000+(UU(ry.a)<<5)+UU(rx.a))
    {PPUDATA}(rt)

    ppu_set_addr($2096)
    {PPUDATA}(u_to_dd(score)[1] + $30)
    {PPUDATA}(u_to_dd(score)[0] + $30)

    if (orx.a != rx.a || ory.a != ry.a)
        ortele = rtele

fn move_player()
    
    if optailt_counter == 0
        optailt = ptailt
        optailt_counter = plength+2

    opvelx = pvelx
    opvely = pvely

    //move snake head horizontally
    if pads[0].held & BUTTON_DPAD == BUTTON_LEFT && pvelx == 0 
        pvelx = -0.1
        pvely = 0
        pheadt = 6
        pbodyt = 7
        ptailt = 9
    else if pads[0].held & BUTTON_DPAD == BUTTON_RIGHT && pvelx == 0
        pvelx = 0.1
        pvely = 0
        pheadt = 8
        pbodyt = 7
        ptailt = 5
    //move snake head vertically
    else if pads[0].held & BUTTON_DPAD == BUTTON_UP && pvely == 0
        pvely = -0.1
        pvelx = 0
        pheadt = 20
        pbodyt = 19
        ptailt = 17
    else if pads[0].held & BUTTON_DPAD == BUTTON_DOWN && pvely == 0
        pvely = 0.1
        pvelx = 0
        pheadt = 18
        pbodyt = 19
        ptailt = 4

    if pads[0].held & BUTTON_SELECT
        goto mode win()
        : preserves

    opx = px
    opy = py

    //make sure snake is always moving
    px += pvelx
    py += pvely

    //wrap snake around screen
    if py < 6
        py = 25
    else if py > 26
        py = 6
    
    if px < 2
        px = 29
    else if px > 30
        px = 2

    if (px.a != opx.a) || (py.a != opy.a)
        if optailt_counter > 0
            optailt_counter -= 1
        //store head position at turn
        psnpx[psnpxbi] = px.a
        psnpy[psnpybi] = py.a
        //increment snake buffer index
        psnpxbi += 1
        psnpybi += 1
        if pvelx != opvelx || pvely != opvely
            pturn = true
            if opvelx > 0 && pvely > 0
                pcornt = 22
            else if opvelx > 0 && pvely < 0
                pcornt = 24
            else if opvelx < 0 && pvely > 0
                pcornt = 21
            else if opvelx < 0 && pvely < 0
                pcornt = 23
        else
            pturn = false

fn set_rat()
    //set the old rat position
    //orx = rx
    //ory = ry

    //put rat in random place
    rx = randb(27)
    ry = randb(19)

    //in bounds
    rx += 2
    ry += 6

    if rtele == 1
        //put rat in random place
        rx = randb(27)
        ry = randb(19)

        //in bounds
        rx += 2
        ry += 6
        

fn move_rat()
    orx = rx
    ory = ry
    
    rvelx = SF(pvelx * (SF(score+1)>>5))
    rvely = SF(pvely * (SF(score+1)>>5))

    if rvelx < 0
        rt = 10
    else if rvelx > 0
        rt = 11
    else if rvely > 0
        rt = 26
    else if rvely < 0
        rt = 27

    //rat is always moving
    rx += rvelx
    ry += rvely

    //wrap rat around screen
    if ry < 6
        ry = 25
    else if ry > 26
        ry = 6
    
    if rx < 2
        rx = 29
    else if rx > 30
        rx = 2
    
    if rtele == 1
        score += 1
        plength += 1
        puf.play_sfx(1)
        set_rat()

fn eat_check()
    if px.a == rx.a && py.a == ry.a
        score += 1
        plength += 1
        puf.play_sfx(1)
        set_rat()

fn ouro_check()
    if pleat == 1 && (px.a != opx.a || py.a != opy.a)
        puf.play_sfx(2)
        lost = true

mode lose()
: nmi win_nmi

    // turn NMI off
    {PPUCTRL}(0)
    //turn rendering off
    {PPUMASK}(0)

    load_nametable_tall()

    // have NMI on every frame
    {PPUCTRL}(PPUCTRL_NMI_ON)

    shame_scroll = 0
    shame_counter = 120

    ppu_reset_scroll(0, 0)

    while true
        update_pads()
        pads_menu()
        if shame_counter > 0
            shame_counter -= 1
        else if shame_counter == 0 && shame_scroll < 239
            shame_scroll += 1
        nmi

mode main()
: nmi win_nmi
    // turn NMI off
    {PPUCTRL}(0)
    //turn rendering off
    {PPUMASK}(0)

    // upload palette
    palette = nexxt_default
    ppu_upload_palette()

    load_nametable(@title_back_nt)

    init_arrays()

    // Clear the remainder of OAM
    hide_oam(0)

    // have NMI on every frame
    {PPUCTRL}(PPUCTRL_NMI_ON)

    puf.init(system)
    puf.play_track(puf_track_title)

    while true
        update_pads()
        pads_menu()
        nmi

fn pads_menu()
    if pads[0].held & BUTTON_START
        goto mode game()
        : preserves /serp_vars


// Define the tileset (commonly called CHR):
chrrom
    file(fmt, "serchr.png")

audio(puf1_music, "music.txt")
audio(puf1_sfx, "sfx.txt", "sfx.nsf")